Fullstack Advanced React & GraphQL https://advancedreact.com/

Imports:
- import Link from 'next/link'                                                  - Next.js's Link API
- import styled, { ThemeProvider, injectGlobal } from 'styled-components';
    {injectGlobal}                                                              - To add global styles to your page
    {ThemeProvider}                                                             - wrapper component for theming support
- import Router from 'next/router';
- import NProgress from 'nprogress';
- import PropTypes from 'prop-types';                                           - To run typechecking on the props for a component https://reactjs.org/docs/typechecking-with-proptypes.html
- import gql from 'graphql-tag';                                                - utilities for parsing GraphQL queries

Terminal Errors:
- ReferenceError: Query is not defined 
    --> means there are missing imports, check imports in the 1st file mentioned.
- networkError:{ Error: Response not successful: Received status code 400...} 
    --> check the error above or find the error in Network tab in browser.

================ ================ ================ ================  ================ ================
================ Module 1 - Introduction and Setup (40min)================ 
================ ================ ================ ================ 

================ #1 — Editor Setup and Starter Files Installation (08:29)
> git clone https://github.com/wesbos/Advanced-React.git
> cd Advanced-React/sick-fits/
> npm install       // in 'frontend/' and 'backend/' folders

================ #2 — Sick Fits and the Tech Stack Behind It (10:30)
================ #3 — An Intro to Next.js, Tooling and Routing (08:50)
> cd frontend/
> npm run dev       // open http://localhost:7777/ in browser
Create /pages/index.js(stateless component), /pages/sell.js(stateless component) -> insert React class/function component ->
-> insert Routing with <Link> between these pages (check doc: https://nextjs.org/learn/basics/navigate-between-pages/using-link)
    
================ #4 — Custom _app.js Layout (12:25)  
FRONTEND
Create /pages/_app.js (for some data to show up on each page - to override the App class). Check doc https://nextjs.org/docs#custom-app
    - copy component from doc but remove pageProps (not sure why??)
    - import { Container } from 'next/app' (didn't find doc on it??), Page component
    - insert code
        (<Container>
            <Page>
            <Component />
            </Page>
      </Container>)
Create Page.js, Meta.js, Header.js, Nav.js  under components folder. Insert React Components.
    Page.js (class component)
        - import Header and Meta components
        - insert the following code into component:
            <Meta />
            <Header />
            {this.props.children}
    Meta.js (stateless component). 
        - if you get 'Invariant Violation: Meta(...): Nothing was returned from render.' error -> change braces from {} to ()
        - import Head from 'next/head';
        - insert the following code into component:
            <Head>
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <meta charSet="utf-8" />
                <link rel="shortcut icon" href="/static/favicon.png" />
                <link rel="stylesheet" type="text/css" href="/static/nprogress.css" />
                <title>Sick Fits!</title>
            </Head>
    Header.js (stateless component)
        - import Nav component
        - insert the following code into component:
            <div className="bar">
                <a href="">Sick Fits</a>
                <Nav />
            </div>
            <div className="sub-bar">
                <p>Search</p>
            </div>
            <div>Cart</div>
    Nav.js (stateless component)
        - import Link
        - insert the following code into component:
            <Link href="/sell">
                <a>Sell!</a>
            </Link>
            <Link href="/">
                <a>Home!</a>
            </Link>

------------ Some notes -------------
Functional vs Class-Components in React:
    - functional component is just a plain JavaScript function, you cannot use setState() in your component. That’s the reason why they also get called functional stateless components.
    - you cannot use lifecycle hooks in functional components.
    - Advantages of functional components:
        - easier to read and test
        - less code

Snippets:        
    rcc - class component skeleton
    rsc - stateless component skeleton

this.props.children (or props.children if you are using stateless functions - P.S. но тогда в аргумент передаешь props)
    The React docs say that you can use props.children on components that represent ‘generic boxes’ and that ‘don’t know their children ahead of time’.
    check doc: https://codeburst.io/a-quick-intro-to-reacts-props-children-cb3d2fce4891
-------------------------------------

================ ================ ================ ================ ================ ================
================ Module 2 - CSS and Styled Components (51min) ================ 
================ ================ ================ ================ 

================ #5 — An Intro to Styled Components (11:19)
Nothing to code. Just play with styled components in Page.js file. For example, add import of it, create button, add styles.

================ #6 — Themes and Layout with Styled Components (18:51)
Add some styles to Page.js and Header.js. Plus: ThemeProvider, context API.
    Page.js
        - import styled, { ThemeProvider, injectGlobal } from 'styled-components';
        - wrap code in <ThemeProvider theme={theme}></ThemeProvider> tags and add styles:
            const theme = {
                red: '#FF0000',
                black: '#393939',
                grey: '#3A3A3A',
                lightgrey: '#E1E1E1',
                offWhite: '#EDEDED',
                maxWidth: '1000px',
                bs: '0 12px 24px 0 rgba(0, 0, 0, 0.09)'
            };
        - change <div> to <StyledPage> component and add styles:
            const StyledPage = styled.div`
                background: white;
                color: ${props => props.theme.black};
            `;
        - wrap {this.props.children} in <Inner></Inner> and add styles:
            const Inner = styled.div`
                max-width: ${props => props.theme.maxWidth};
                margin: 0 auto;
                padding: 2rem;
            `;
    Header.js
        - import Link and styled
        - wrap sick fits link into <Logo> component and add styles:
            const Logo = styled.h1`
                font-size: 4rem;
                margin-left: 2rem;
                position: relative;
                z-index: 2;
                transform: skew(-7deg);
                a {
                    padding: 0.5rem 1rem;
                    background: ${props => props.theme.red};
                    color: white;
                    text-transform: uppercase;
                    text-decoration: none;
                }
                @media (max-width: 1300px) {
                    margin: 0;
                    text-align: center;
                }
            `;
        - wrap all code into <StyledHeader> and add styles:
            const StyledHeader = styled.header`
                .bar {
                    border-bottom: 10px solid ${props => props.theme.black};
                    display: grid;
                    grid-template-columns: auto 1fr;
                    justify-content: space-between;
                    align-items: stretch;
                    @media (max-width: 1300px) {
                    grid-template-columns: 1fr;
                    justify-content: center;
                    }
                }
                .sub-bar {
                    display: grid;
                    grid-template-columns: 1fr auto;
                    border-bottom: 1px solid ${props => props.theme.lightgrey};
                }
            `;

------------ Some notes -------------
ThemeProvider   https://www.styled-components.com/docs/advanced
(??deprecated)injectGlobal    https://www.styled-components.com/docs/api
-------------------------------------

================ #7 — Global Styling and Typography with Styled Components (10:50)
Change the order of imports - external first, then relative imports. 
Add injectGlobal styles(global styles) in Page.js:
    injectGlobal`
        @font-face {
            font-family: 'radnika_next';
            src: url('/static/radnikanext-medium-webfont.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }
        html {
            box-sizing: border-box;
            font-size: 10px;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }
        body {
            padding: 0;
            margin: 0;
            font-size: 1.5rem;
            line-height: 2;
            font-family: 'radnika_next';
        }
        a {
            text-decoration: none;
            color: ${theme.black};
        }
    `;

Add styles to Nav.js:
    - import NavStyles from './styles/NavStyles';
    - wrap code into import NavStyles component
    - change navigation links to:
        <Link href="/items">
            <a>Items</a>
        </Link>
        <Link href="/sell">
            <a>Sell</a>
        </Link>
        <Link href="/signup">
            <a>Signup</a>
        </Link>
        <Link href="/orders">
            <a>Orders</a>
        </Link>
        <Link href="/me">
            <a>Account</a>
        </Link>


================ #8 — Visualizing Route Changes (06:44)
Add NProgress bar in the Header.js 
    - add imports 
        import Router from 'next/router';
        import NProgress from 'nprogress';
    - add code after imports:
        Router.onRouteChangeStart = () => {
            NProgress.start();
        };

        Router.onRouteChangeComplete = () => {
            NProgress.done();
        };

        Router.onRouteChangeError = () => {
            NProgress.done();
        };

------------ Some notes -------------
Check Router events in Next documentation 
    https://nextjs.org/docs#router-events
    https://github.com/zeit/next.js/#router-events).
Check nprogress https://ricostacruz.com/nprogress/

================ #9 — Fixing Styled Components Flicker on Server Render (04:18)
Fix unstyled website as you refresh: add /pages/_document.js (take it from next doc).

------------ Some notes -------------
?? Doesn't work from here(I had to copy from wesbos answer):
    https://nextjs.org/docs#custom-document
    https://www.styled-components.com/docs/advanced -> search 'Basically you need to add a custom pages/_document.js' -> https://github.com/zeit/next.js/blob/master/examples/with-styled-components/pages/_document.js

================ ================ ================ ================  ================ ================
================ Module 3 - Server Side GraphQL (1h 37min)================ 
================ ================ ================ ================ 

================ #10 — An intro to GraphQL (14:13)
Nothing to code. Learn what is GraphQL, play with queries in Prisma playground. Check schema(queries, mutatations).
Resolvers.

================ #11 — Getting Setup with Prisma (22:55)
Sign up for Prisma Demo Server.
BACKEND
    > npm i -g prisma
    > prisma login
    > prisma init
    > git status    // 2 files will be created - datamodel.graphql(in my case datamodel.prisma) & prisma.yml
    
Rename variables.env.sample to variables.env    (never push this file to production, github etc).
Hide endpoint from prisma.yml to .env file. 
Rename 'datamodel: datamodel.graphql' to 'datamodel: datamodel.prisma' in prisma.yml.
Add to prisma.yml file: 1) secret - comment it, uncomment when you go to production, 2) hooks.
    # secret: ${env:PRISMA_SECRET}
    hooks:
        post-deploy:
            - graphql get-schema -p prisma  // или - prisma generate как в инструкции https://www.prisma.io/docs/get-started/02-change-data-model-JAVASCRIPT-c001/

> prisma deploy     // prisma deploy --help, prisma deploy -e variables.env
OR
> npm run deploy    // it's added script for the command above.

Check Prisma Console - now you should see a new service.
> git status    // src/generated/prisma.graphql will be modified - all API are created and lives here.

Redeploy after each change in datamodel.
Now experiment with queries and mutatations in Prisma playground.

------------ Some notes -------------
Using env variables inside prisma.yml https://www.prisma.io/docs/1.2/reference/service-configuration/prisma.yml/using-variables-nu5oith4da


================ #12 — Getting our GraphQL Yoga Server Running (22:32)
Check doc 'Build a GraphQL server from scratch' https://www.prisma.io/docs/1.10/tutorials/build-graphql-servers/development/build-a-graphql-server-from-scratch-nahgaghei6 ).

1) Create /src/db.js (check 'prisma-binding' documentation).
    // из примера данного в статье сюда выносим секцию с new GraphQLServer -> db

    const { Prisma } = require('prisma-binding');

    const db = new Prisma({
        typeDefs: 'src/generated/prisma.graphql',
        endpoint: process.env.PRISMA_ENDPOINT,
        secret: process.env.PRISMA_SECRET,
        debug: false,
    });

    module.exports = db;

2) Create /src/createServer.js
    // из примера данного в статье сюда выносим секцию с new GraphQLServer

    const { GraphQLServer } = require('graphql-yoga');
    const Mutation = require('./resolvers/Mutation');
    const Query = require('./resolvers/Query');
    const db = require('./db');

    // Create the GraphQL Yoga Server

    function createServer() {
        return new GraphQLServer({
            typeDefs: 'src/schema.graphql',
            resolvers: {
                Mutation,
                Query,
            },
            resolverValidationOptions: {
                requireResolversForResolveType: false,
            },
            context: req => ({ ...req, db }),
        });
    }

    module.exports = createServer;

3) Create /src/schema.graphql
    type Mutation {
        hi: String
    }

    type Query {
        hi: String
    }

4) Start server in /src/index.js 
    require('dotenv').config({ path: 'variables.env' });
    const createServer = require('./createServer');
    const db = require('./db');

    const server = createServer();

    // TODO Use express middlware to handle cookies (JWT)
    // TODO Use express middlware to populate current user

    server.start(
        {
            cors: {
            credentials: true,
            origin: process.env.FRONTEND_URL,
            },
        },
        deets => {
            console.log(`Server is now running on port http:/localhost:${deets.port}`);
        }
    );

> npm run dev   // OR node src/index.js     (turn on debug & playground)
OR
> npm run debug // (?? we don't have debug script) to start the server (using 'nodemon' package)

------------ Some notes -------------
process.env https://nodejs.org/api/process.html#process_process_env
Dotenv is a zero-dependency module that loads environment variables from a .env file into process.env.
Nodemon is a utility that will monitor for any changes in your source and automatically restart your server. Perfect for development. https://www.npmjs.com/package/nodemon
nodemon -e  - to specify extension

?? как прочитать эту строку context: req => ({ ...req, db })

================ #13 — Our first Query and Mutation (11:40)
Nothing to code. Experiment with schema.graphql & resolvers(Query.js, Mutation.js), e.g. dogs.

================ #14 — Items Creation and Prisma Yoga Flow (26:07)
Make changes in:
1) datamodel.prisma: add 'Item' type.
    type Item {
        id: ID! @unique
        title: String!
        description: String!
        image: String
        largeImage: String
        price: Int!
        # createAt: DateTime!
        # updatedAt: DateTime!
        # user: User!
    }
2) schema.graphql: create method 'createItem' under Mutation, # import * from './generated/prisma.graphql', add Query.
    # import * from './generated/prisma.graphql'

    type Mutation {
        createItem(title: String, description: String, price: Int, image: String, largeImage: String): Item!
    }

    type Query {
        items: [Item]!
    }

3) Query.js
    const { forwardTo } = require('prisma-binding');

    const Query = {
        items: forwardTo('db'),
    };

    module.exports = Query;

4) Mutation.js

    const Mutations = {
        async createItem(parent, args, ctx, info) {
            // TODO: Check if they are logged in

            const item = await ctx.db.mutation.createItem(
                {
                    data: {
                        ...args,
                    },
                },
                info
            );

            console.log(item);

            return item;
        },
        // createDog(parent, args, ctx, info) {
        //   global.dogs = global.dogs || [];
        //   // create a dog
        //   const newDog = { name: args.name };
        //   global.dogs.push(newDog);
        //   return newDog;
        // },
    };

    module.exports = Mutations;

------------ Some notes -------------
forwardTo   - If you just want to forward a query to the exact same underlying prisma query, you can use forwardTo:

A resolver function takes 4 arguments:
    - parent:   The result of the previous resolver call (more info).
    - args:     The arguments of the resolver’s field.
        e.g. 
            args { title: 'DTt', description: 'fgsdg', price: 34 }
    - context:  A custom object each resolver can read from/write to.
        e.g.
            { 
                request:
                    IncomingMessage { .......... }
                response:
                    ServerResponse { ........... },
                    fragmentReplacements: [],
                    db:
                        Prisma { ............ },
                        _extensionStack: GraphQLExtensionStack { extensions: [ [TracingExtension] ] } 
            }
    - info: 
        e.g. 
            { 
                fieldName: 'createItem',
                fieldNodes: [ .......... ],
                returnType: Item!,
                parentType: Mutation,
                path: { prev: undefined, key: 'createItem' },
                schema: GraphQLSchema { ........... },
                fragments: [Object: null prototype] {},
                rootValue: undefined,
                operation: { .......... },
                variableValues: {} 
            }

Good doc https://www.tutorialspoint.com/graphql/graphql_mutation.htm

@updatedAt | @createdAt | @id
    The id , createdAt and updatedAt fields are managed by Prisma and read-only in the exposed Prisma API (meaning they can not be altered via mutations).

Check doc 'Build an App' with GraphQL API or REST API https://www.prisma.io/docs/get-started/03-build-graphql-servers-with-prisma-JAVASCRIPT-e001/

================ ================ ================ ================  ================ ================
================ Module 4 - Client Side GraphQL (2h 33min) ================ 
================ ================ ================ ================ 
================ #15 — Setting Up Apollo Client with React (11:24)
FRONTEND
Check lib/withData.js (it's already made by wesbos for us). 
Modify _app.js: check doc https://github.com/lfades/next-with-apollo, import ApolloProvider, 
    - add imports
        import { ApolloProvider } from 'react-apollo';
        import withData from '../lib/withData';
    - wrap <Page></Page> component with <ApolloProvider client={apollo}></ApolloProvider> component
    - add {...pageProps} to <Component />
    - modify export, should be 'export default withData(MyApp);'
    - add 'pageProps, apollo' to const {Component} so it's const { Component, apollo, pageProps } = this.props;
    - add code before render
        static async getInitialProps({ Component, ctx }) {
            let pageProps = {};
            if (Component.getInitialProps) {
                pageProps = await Component.getInitialProps(ctx);
            }
            // this exposes the query to the user
            pageProps.query = ctx.query;
            return { pageProps };
        }


------------ Some notes -------------
Check Apollo Client(state management library) doc https://www.apollographql.com/docs/react/
    Apollo includes two runtime libraries, Apollo Server and Apollo Client
GraphQL Glossary https://www.apollographql.com/docs/resources/graphql-glossary/

================ #16 — React Meets GraphQL (25:54)
Create pages/items.js - (it's the same frontend as homepage) - just import homepage.
    import Home from 'index.js';
    export default Home;

Create components/Items.js, add code:
    import React, { Component } from 'react';
    import { Query } from 'react-apollo';
    import gql from 'graphql-tag';
    import styled from 'styled-components';
    import Item from './Item';

    const ALL_ITEMS_QUERY = gql`
        query ALL_ITEMS_QUERY {
            items {
            id
            title
            price
            description
            image
            largeImage
            }
        }
    `;

    const Center = styled.div`
        text-align: center;
    `;

    const ItemsList = styled.div`
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 60px;
        max-width: ${props => props.theme.maxWidth};
        margin: 0 auto;
    `;

    class Items extends Component {
        render() {
            return (
            <Center>
                <Query query={ALL_ITEMS_QUERY}>
                {({ data, error, loading }) => {
                    if (loading) return <p>Loading...</p>;
                    if (error) return <p>Error: {error.message}</p>;
                    return (
                    <ItemsList>{data.items.map(item => <Item item={item} key={item.id} />)}</ItemsList>
                    );
                }}
                </Query>
            </Center>
            );
        }
    }
    export default Items;
    export { ALL_ITEMS_QUERY };

Create components/Item.js, add code:
    import React, { Component } from 'react';
    import PropTypes from 'prop-types';
    import Link from 'next/link';
    import Title from './styles/Title';
    import ItemStyles from './styles/ItemStyles';
    import PriceTag from './styles/PriceTag';
    import formatMoney from '../lib/formatMoney';

    export default class Item extends Component {
        static propTypes = {
            item: PropTypes.object.isRequired,
        };

        render() {
            const { item } = this.props;
            return (
            <ItemStyles>
                {item.image && <img src={item.image} alt={item.title} />}

                <Title>
                <Link
                    href={{
                    pathname: '/item',
                    query: { id: item.id },
                    }}
                >
                    <a>{item.title}</a>
                </Link>
                </Title>
                <PriceTag>{formatMoney(item.price)}</PriceTag>
                <p>{item.description}</p>

                <div className="buttonList">
                <Link
                    href={{
                    pathname: 'update',
                    query: { id: item.id },
                    }}
                >
                    <a>Edit ✏️</a>
                </Link>
                <button>Add To Cart</button>
                <button>Delete </button>
                </div>
            </ItemStyles>
            );
        }
    }

Add import of Items.js to index.js and replace <p>Home</p> with <Items /> component.
In /components/Nav.js change 'Items' title to 'Shop'.

------------ Some notes ------------- 
- Higher-Order Components https://reactjs.org/docs/higher-order-components.html
- Render Props(this time we use it instead of HOC, used in Items.js) https://reactjs.org/docs/render-props.html
- proptypes (we use it in Item.js) https://reactjs.org/docs/typechecking-with-proptypes.html#proptypes

Destructuring Props in React https://medium.com/@lcriswell/destructuring-props-in-react-b1c295005ce0
Destructuring assignment https://stackoverflow.com/questions/51012674/reactjs-why-use-const-this-props-and-why-put-it-inside-the-render-function/51012767
React Properties https://medium.com/react-tutorials/react-properties-ef11cd55caa0
Fetch data with queries https://www.apollographql.com/docs/tutorial/queries/

Queries: Apollo Client's support for React Hooks https://www.apollographql.com/docs/react/data/queries/
    To perform queries with Apollo Client's render-prop API(previous version)
        https://www.apollographql.com/docs/react/v2.5/essentials/queries/


================ #17 — Creating Items with Mutations (29:50)
We'll be working on C - create - from CRUD (It's /sell page).
Open sell.js:
    import CreateItem from '../components/CreateItem'
    replace <p>Sell</p> with <CreateItem /> component.
Create components/CreateItem.js: writing a mutation and adding a form to add an item.
    - rcc
    - add imports:
        import { Mutation } from 'react-apollo';
        import gql from 'graphql-tag';
        import Router from 'next/router';
        import Form from './styles/Form';
        import formatMoney from '../lib/formatMoney';
        import Error from './ErrorMessage';
    - create a GraphQL mutation:
        const CREATE_ITEM_MUTATION = gql`
            mutation CREATE_ITEM_MUTATION(
                $title: String!
                $description: String!
                $price: Int!
                $image: String
                $largeImage: String
            ) {
                createItem(
                    title: $title
                    description: $description
                    price: $price
                    image: $image
                    largeImage: $largeImage
                    ) {
                    id
                }
            }
        `;
    - modify code in component:
        class CreateItem extends Component {
            state = {
                title: 'Cool Shoes',
                description: 'I love those shoes',
                image: 'dog.jpg',
                largeImage: 'large-dog.jpg',
                price: 1000,
            };
            handleChange = e => {
                const { name, type, value } = e.target;
                const val = type === 'number' ? parseFloat(value) : value;
                this.setState({ [name]: val });
            };
            render() {
                return (
                <Mutation mutation={CREATE_ITEM_MUTATION} variables={this.state}>
                    {(createItem, { loading, error }) => (
                    <Form
                        onSubmit={async e => {
                        // Stop the form from submitting
                        e.preventDefault();
                        // call the mutation
                        const res = await createItem();
                        // change them to the single item page
                        console.log(res);
                        Router.push({
                            pathname: '/item',
                            query: { id: res.data.createItem.id },
                        });
                        }}
                    >
                        <Error error={error} />
                        <fieldset disabled={loading} aria-busy={loading}>
                        <label htmlFor="title">
                            Title
                            <input
                            type="text"
                            id="title"
                            name="title"
                            placeholder="Title"
                            required
                            value={this.state.title}
                            onChange={this.handleChange}
                            />
                        </label>

                        <label htmlFor="price">
                            Price
                            <input
                            type="number"
                            id="price"
                            name="price"
                            placeholder="Price"
                            required
                            value={this.state.price}
                            onChange={this.handleChange}
                            />
                        </label>

                        <label htmlFor="description">
                            Description
                            <textarea
                            id="description"
                            name="description"
                            placeholder="Enter A Description"
                            required
                            value={this.state.description}
                            onChange={this.handleChange}
                            />
                        </label>
                        <button type="submit">Submit</button>
                        </fieldset>
                    </Form>
                    )}
                </Mutation>
                );
            }
        }
        export default CreateItem;
        export { CREATE_ITEM_MUTATION };

Learn:
- external upload APIs, e.g. Cloudinary.

Mutations https://www.howtographql.com/react-apollo/3-mutations-creating-links/
React State without Constructor(we no longer need a constructor): https://hackernoon.com/the-constructor-is-dead-long-live-the-constructor-c10871bea599

================ #18 — Uploading Images (11:46)
Cloudinary -> Settings -> 'Upload' tab -> Upload presets: Add upload preset -> type 'Preset name', 
choose 'Mode: Unsigned', add 'Folder' name, Incoming Transformation (set the width(500), delete height, mode: scale, 
format: auto), Eager Transformations (set the width(1000), mode: scale, format: auto) -> Save.

Modify CreateItem component:
    - Add method called 'uploadFile' (put it before render)(?? откуда взят код непонятно):
        uploadFile = async e => {
            console.log('uploading file...');
            const files = e.target.files;
            const data = new FormData();
            data.append('file', files[0]);
            data.append('upload_preset', 'sickfits');

            const res = await fetch('https://api.cloudinary.com/v1_1/wesbostutorial/image/upload', {
            method: 'POST',
            body: data,
            });
            const file = await res.json();
            console.log(file);
            this.setState({
            image: file.secure_url,
            largeImage: file.eager[0].secure_url,
            });
        };
    - Add image input: 
        <label htmlFor="file">
            Image
            <input
                type="file"
                id="file"
                name="file"
                placeholder="Upload an image"
                required
                onChange={this.uploadFile}
            />
            {this.state.image && (
                <img width="200" src={this.state.image} alt="Upload Preview" />
            )}
        </label>

We've got R - read - from CRUD.

================ #19 — Updating Items with Queries and Mutations (25:42)
We'll be working on U - update - from CRUD.

BACKEND - to update interface
Open schema.graphql: 
    - add 'updateItem' to Mutation type, 
        updateItem(id: ID!, title: String, description: String, price: Int): Item!
    - add 'item(where: ItemWhereUniqueInput)' to Query(taken from prisma.graphql).
        item(where: ItemWhereUniqueInput!): Item
Open Query.js(resolver) -> add 'item' to Query:
        item: forwardTo('db'),
Open Mutation.js -> add updateItem to Mutations:
        async updateItem(parent, args, ctx, info) {
            // first take a copy of the updates
            const updates = { ...args };
            // remove the ID from the updates
            delete updates.id;
            // run the update method
            return ctx.db.mutation.updateItem(
                {
                    data: updates,
                    where: {
                        id: args.id
                    }
                },
                info
            );
        } 

FRONTEND
Create /components/UpdateItem.js (copy of CreateItem.js).
    - rename CreateItem to UpdateItem
    - rename CREATE_ITEM_MUTATION to UPDATE_ITEM_MUTATION, modify it:
        const UPDATE_ITEM_MUTATION = gql`
            mutation UPDATE_ITEM_MUTATION($id: ID!, $title: String, $description: String, $price: Int) {
                updateItem(id: $id, title: $title, description: $description, price: $price) {
                id
                title
                description
                price
                }
            }
        `;
    - remove uploadFile handler
    - remove image from fieldset
    - remove everything from initial state: state{}
    - create SINGLE_ITEM_QUERY
        const SINGLE_ITEM_QUERY = gql`
            query SINGLE_ITEM_QUERY($id: ID!) {
                item(where: { id: $id }) {
                id
                title
                description
                price
                }
            }
        `;
    - add method before render:
        updateItem = async (e, updateItemMutation) => {
            e.preventDefault();
            console.log('Updating Item!!');
            console.log(this.state);
            const res = await updateItemMutation({
            variables: {
                id: this.props.id,
                ...this.state,
            },
            });
            console.log('Updated!!');
        };
    - nest Mutations inside of Query
        <Query
            query={SINGLE_ITEM_QUERY}
            variables={{
            id: this.props.id,
            }}
        >{({ data, loading }) => {
          if (loading) return <p>Loading...</p>;
          if (!data.item) return <p>No Item Found for ID {this.props.id}</p>;
          return (
              <Mutation>..........</Mutation>
               );
        }}
        </Query>
    - change onSubmit in <Form> to:
        onSubmit={e => this.updateItem(e, updateItem)}>
    - make changes in:
        - Title fieldset 
            before: value={this.state.title}
            after:  defaultValue={data.item.title}
        - Price fieldset 
            before: value={this.state.price}
            after:  defaultValue={data.item.price}
        - Description fieldset 
            before: value={this.state.description}
            after:  defaultValue={data.item.description}
    - change submit button:
            before: <button type="submit">Submit</button>
            after:  <button type="submit">Sav{loading ? 'ing' : 'e'} Changes</button>

Create /pages/update.js:
    - copy everything from sell.js and paste it in update.js
    - replace CreateItem with UpdateItem
        const Sell = ({ query }) => (                   // destructure props to ({ query })
            <div>
                <UpdateItem id={query.id} />            // add id={query.id}
            </div>
        );

Note: changes won't be visible until you refresh the page.

================ #20 — Deleting Items (13:04)
Create /components/DeleteItem.js -> rcc (create a new component).
Go to Item.js -> import that component -> insert it in code instead of button tag:
    <DeleteItem id={item.id}>Delete This Item</DeleteItem>

BACKEND
Open schema.graphql -> add 'deleteItem' mutation:
    deleteItem(id: ID!): Item
Go to Mutation.js -> add deleteItem:
    async deleteItem(parent, args, ctx, info) {
        const where = { id: args.id };
        // 1. find the item
        const item = await ctx.db.query.item({ where }, `{ id title}`);
        // 2. Check if they own that item, or have the permissions
        // TODO
        // 3. Delete it!
        return ctx.db.mutation.deleteItem({ where }, info);
    },

FRONTEND
Open DeleteItem.js -> add DELETE_ITEM_MUTATION
    - add graphql mutation:
        const DELETE_ITEM_MUTATION = gql`
            mutation DELETE_ITEM_MUTATION($id: ID!) {
                deleteItem(id: $id) {
                id
                }
            }
        `;
    - add imports:
        import gql from 'graphql-tag';
        import {Mutation} from 'react-apollo';
        import { ALL_ITEMS_QUERY } from './Items';
    - return:
        <Mutation
            mutation={DELETE_ITEM_MUTATION}
            variables={{ id: this.props.id }}
            update={this.update}
        >
            {(deleteItem, { error }) => (
            <button
                onClick={() => {
                if (confirm('Are you sure you want to delete this item?')) {
                    deleteItem();
                }
                }}
            >
                {this.props.children}
            </button>
            )}
        </Mutation> 
    - add method before render:
        update = (cache, payload) => {
            // manually update the cache on the client, so it matches the server
            // 1. Read the cache for the items we want
            const data = cache.readQuery({ query: ALL_ITEMS_QUERY });
            console.log(data, payload);
            // 2. Filter the deleted item out of the page
            data.items = data.items.filter(item => item.id !== payload.data.deleteItem.id);
            // 3. Put the items back!
            cache.writeQuery({ query: ALL_ITEMS_QUERY, data });
        };

================ #21 — Displaying Single Items (12:33)
Create /pages/item.js (copy of index.js, rename Home to Item, import SingleItem component, insert <SingleItem id={props.query.id} />). 
Create /components/SingleItem.js -> rcc:
    - add imports:
        import gql from 'graphql-tag';
        import { Query } from 'react-apollo';
        import Error from './ErrorMessage';
        import styled from 'styled-components';
        import Head from 'next/head';
    - add SINGLE_ITEM_QUERY:
        const SINGLE_ITEM_QUERY = gql`
            query SINGLE_ITEM_QUERY($id: ID!) {
                item(where: { id: $id }) {
                    id
                    title
                    description
                    largeImage
                }
            }
        `;
    - write error checking in SingleItem component. 
    - add styles:
        const SingleItemStyles = styled.div`
            max-width: 1200px;
            margin: 2rem auto;
            box-shadow: ${props => props.theme.bs};
            display: grid;
            grid-auto-columns: 1fr;
            grid-auto-flow: column;
            min-height: 800px;
            img {
                width: 100%;
                height: 100%;
                object-fit: contain;
            }
            .details {
                margin: 3rem;
                font-size: 2rem;
            }
        `;
    - return:
        <Query
            query={SINGLE_ITEM_QUERY}
            variables={{
                id: this.props.id,
            }}
        >
            {({ error, loading, data }) => {
            if (error) return <Error error={error} />;
            if (loading) return <p>Loading...</p>;
            if (!data.item) return <p>No Item Found for {this.props.id}</p>;
            const item = data.item;
            return (
                <SingleItemStyles>
                <Head>
                    <title>Sick Fits | {item.title}</title>
                </Head>
                <img src={item.largeImage} alt={item.title} />
                <div className="details">
                    <h2>Viewing {item.title}</h2>
                    <p>{item.description}</p>
                </div>
                </SingleItemStyles>
            );
            }}
        </Query>
To change meta title(in web page tab): import Head from 'next/head' and insert <Head>Another | Title</Head>

================ #22 — Pagination (15:12)
Create at least 9 items.
Create /components/Pagination.js

BACKEND
Open schema.graphql -> add 'itemsConnection' under Query:
    itemsConnection(where: ItemWhereInput): ItemConnection!
Open Query.js -> add itemsConnection under Query: 
    itemsConnection: forwardTo('db'),
In playground:
    query dataAboutItems {
        itemsConnection {
            aggregate {
                count           // will return 9.
            }
        }
    }

FRONTEND
In Pagination.js:
    - rsc (stateless component)
    - add imports:
        import gql from 'graphql-tag';
        import { Query } from 'react-apollo';
        import Head from 'next/head';
        import Link from 'next/link';
        import PaginationStyles from './styles/PaginationStyles';
        import { perPage } from '../config';
    - make a query PAGINATION_QUERY:
        const PAGINATION_QUERY = gql`
            query PAGINATION_QUERY {
                itemsConnection {
                    aggregate {
                        count
                    }
                }
            }
        `;
    - add imports:
        import gql from 'graphql-tag';
        import { Query } from 'react-apollo';
        import Head from 'next/head';
        import Link from 'next/link';
        import PaginationStyles from './styles/PaginationStyles';
        import { perPage } from '../config';
    -   add code:
        const Pagination = props => (
            <Query query={PAGINATION_QUERY}>
            {({ data, loading, error }) => {
            if (loading) return <p>Loading...</p>;
            const count = data.itemsConnection.aggregate.count;
            const pages = Math.ceil(count / perPage);
            const page = props.page;
            return (
                <PaginationStyles>
                <Head>
                    <title>
                    Sick Fits! — Page {page} of {pages}
                    </title>
                </Head>
                <Link
                    prefetch
                    href={{
                    pathname: 'items',
                    query: { page: page - 1 },
                    }}
                >
                    <a className="prev" aria-disabled={page <= 1}>
                    ← Prev
                    </a>
                </Link>
                <p>
                    Page {props.page} of {pages}!
                </p>
                <p>{count} Items Total</p>
                <Link
                    prefetch
                    href={{
                    pathname: 'items',
                    query: { page: page + 1 },
                    }}
                >
                    <a className="prev" aria-disabled={page >= pages}>
                    Next →
                    </a>
                </Link>
                </PaginationStyles>
            );
            }}
        </Query>
        );
     
Open config.js -> you see 'export const perPage = 4;' -> import it into Pagination.js.
Open index.js -> add <Items page={parseFloat(props.query.page) || 1} />

================ #23 — Pagination and Cache Invalidation (09:37)
BACKEND
In schema.graphql modify 'items' under Query(add 'where:...'):
    items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, first: Int): [Item]!

FRONTEND
In items.js 
    - add imports:
        import Pagination from './Pagination';
        import { perPage } from '../config';
    - modify ALL_ITEMS_QUERY:
        query ALL_ITEMS_QUERY($skip: Int = 0, $first: Int = ${perPage}) {
        items(first: $first, skip: $skip, orderBy: createAt_DESC) {             // note!! it's not createdAt_DESC but createAt_DESC
    - add before opening tag <Query>:
        <Pagination page={this.props.page} />
    - add after closing tag </Query>:
        <Pagination page={this.props.page} />
    - add attribute to <Query>:
        // fetchPolicy="network-only"
        variables={{
            skip: this.props.page * perPage - perPage,
        }}

================ ================ ================ ================  ================ ================
================ Module 5 - Accounts, Authentication and Permissions (3h 12min)================ 
================ ================ ================ ================ 
Creating users, hashing passwords, storing passwords, signing the user in, signing the user up, signing the user out.

================ #24 — User Signup and Permission Flow (23:07)
BACKEND
In datamodel.graphql add:

    type User {
        id: ID! @unique
        name: String!
        email: String! @unique
        password: String!           // add
        resetToken: String          // add
        resetTokenExpiry: String    // add
        permissions: [Permission] @scalarList(strategy: RELATION)   // add
    }

    enum Permission {
        ADMIN
        USER 
        ITEMCREATE
        ITEMUPDATE
        ITEMDELETE
        PERMISSIONUPDATE
    }
Redeploy after making changes in datamodel.graphql.

In schema.graphql: 
    - create 'signup' Mutation:
        signup(email: String!, password: String!, name: String!): User!
In Mutation.js:
    - import bcrypt.js for hashing the password:
        const bcrypt = require('bcryptjs');
        const jwt = require('jsonwebtoken');
    - create 'signup' resolver:
        async signup(parent, args, ctx, info) {
            // lowercase their email
            args.email = args.email.toLowerCase();
            // hash their password
            const password = await bcrypt.hash(args.password, 10);
            // create the user in the database
            const user = await ctx.db.mutation.createUser(
                {
                    data: {
                        ...args,
                        password,
                        permissions: { set: ['USER'] }
                    }
                },
                info
            );
            // create the JWT token for them
            const token = jwt.sign({ userId: user.id }, process.env.APP_SECRET);
            // We set the jwt as a cookie on the response
            ctx.response.cookie('token', token, {
                httpOnly: true,
                maxAge: 1000 * 60 * 60 * 24 * 365 // 1 year cookie
            });
            // Finalllllly we return the user to the browser
            return user;
        }
In index.js:
    - import 'cookie-parser':
        const cookieParser = require('cookie-parser');
    - add:
        server.express.use(cookieParser());


A middleware is a f-n that will run in the middle between your request and response.
e.g.
REQ     /dogs.html
auth
transform the dogs
local translate

RES     /[dogs, so]


================ #25 — User Signup in React (12:13)
FRONTEND
Create /pages/signup.js -> copy code from sell.js and adapt it:
    import Signup from '../components/Signup';
    import styled from 'styled-components';

    const Columns = styled.div`
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        grid-gap: 20px;
    `;

    const SignupPage = props => (
    <Columns>
        <Signup />
        <Signup />
        <Signup />
    </Columns>
    );

    export default SignupPage;


Create /components/Signup.js -> rcc:
    - add imports:
        import { Mutation } from 'react-apollo';
        import gql from 'graphql-tag';
        import Form from './styles/Form';
        import Error from './ErrorMessage';
    - return a Form:
        class Signup extends Component {
            state = {
                name: '',
                password: '',
                email: '',
            };
            saveToState = e => {
                this.setState({ [e.target.name]: e.target.value });
            };
            render() {
                return (
                <Mutation mutation={SIGNUP_MUTATION} variables={this.state}>
                    {(signup, { error, loading }) => (
                    <Form
                        method="post"
                        onSubmit={async e => {
                            e.preventDefault();
                            await signup();
                            this.setState({ name: '', email: '', password: '' });
                        }}
                    >
                        <fieldset disabled={loading} aria-busy={loading}>
                            <h2>Sign Up for An Account</h2>
                            <Error error={error} />
                            <label htmlFor="email">
                                Email
                                <input
                                type="email"
                                name="email"
                                placeholder="email"
                                value={this.state.email}
                                onChange={this.saveToState}
                                />
                            </label>
                            <label htmlFor="name">
                                Name
                                <input
                                type="text"
                                name="name"
                                placeholder="name"
                                value={this.state.name}
                                onChange={this.saveToState}
                                />
                            </label>
                            <label htmlFor="password">
                                Password
                                <input
                                type="password"
                                name="password"
                                placeholder="password"
                                value={this.state.password}
                                onChange={this.saveToState}
                                />
                            </label>

                            <button type="submit">Sign Up!</button>
                        </fieldset>
                    </Form>
                    )}
                </Mutation>
                );
            }
        }
        export default Signup;

    - add SIGNUP_MUTATION:
        const SIGNUP_MUTATION = gql`
            mutation SIGNUP_MUTATION($email: String!, $name: String!, $password: String!) {
                signup(email: $email, name: $name, password: $password) {
                    id
                    email
                    name
                }
            }
        `;

================ #26 — Currently Logged In User with Middleware and Render Props (18:44)
Inspector -> Application tab -> Cookies -> you'll see 'token' and value contains jwt -> https://jwt.io/, insert that token.

BACKEND
Open index.js
    - we already did server.express middleware for cookie-parser.
    - let's build another middleware (to decode JWT), import jwt
Open schema.graphql
    - add 'me'(current user) to Query
Open Query.js(our resolver)
    - add 'me'

FRONTEND
Create /components/User.js
Make changes in /components/Nav.js: add <User> component.

================ #27 — Sign in Form and Custom Error Handling (16:56)
Cadence: add it to the schema -> add a resolver that's either a query or a mutation, flip over to the frontend,
build some sort of interface for it, and then manage it from there.

Open schema.graphql:
    - create 'signin' mutation, 
Open Mutation.js:
    - implement the signin.
    P.S. async signin(parent, args, ctx, info) -> instead of args.email and args.password -> destructure it ->
    -> {email, password}
Create /components/Signin.js -> copy code from Signup.js. -> rename SIGNUP mutation and others to SIGNIN ->
    -> import { CURRENT_USER_QUERY } from './User'.
Make changes in Nav.js.
    P.S. instead of wrapping in <div> element a block of <Link> tags -> use React fragments for next <> and </>

================ #28 — Sign Out Button (06:21)
Steps are the same as in Signup or Signin.

================ #29 — Backend Password Reset Flow (19:59)
Files to change are the same as in previous tasks. Open schema.graphql: create 'requestReset' mutation..

================ #30 — Frontend Password Reset Flow (14:56)
Copy Signin and adapt to reset.

================ #31 — Sending Email (12:13)
You need SMTP account -> we'll use a service called 'mailtrap' https://mailtrap.io/ for testing purpose.
When you're ready to push your production live, all you have to do is sign up for something like,
I personally use something like Postmark https://postmarkapp.com/. 

Copy information from SMTP settings to variables.env.
    MAIL_HOST="smtp.mailtrap.io"  // copy SMTP host here
    MAIL_PORT=2525
    MAIL_USER="c41..."
    MAIL_PASS="0342.."  // password

Create /src/mail.js -> import nodemailer -> add integration.

================ #32 — Data Relationships (05:47)
Add user: User! relationship to the Item type in datamodel.prisma.

================ #33 — Creating a Gated Sign In Component (05:17)

================ #34 — Permissions Management (22:34)
Create /pages/permissions.js

================ #35 — Updating Permissions in Local State (12:44)

================ #36 — Updating Permissions on the Server (17:30)

================ #37 — Locking Down DeleteItem Permissions (06:38)

================ ================ ================ ================  ================ ================
================ Module 6 - Shopping Cart (1h 29min)================ 
================ ================ ================ ================ 
================ #38 — Creating our cart in React (05:29)
FRONTEND
Create /components/Cart.js -> create Cart component.
Open Header.js -> import Cart component, replace cart text with Cart component in Header component.

================ #39 — Apollo Local State Queries and Mutations (12:30)
Open withData.js -> add local data 'clientState' under request.
Open Cart.js -> add query, mutation,
Make small changes in Nav.js

================ #40 — Server Side Add To Cart (17:04)
BACKEND
Open datamodel.graphql -> add type CartItem.    -> redeploy
Open schema.graphql -> add mutation called addToCart. -> resolver part
Create /components/AddToCart.js
Open Item.js -> import AddToCart component, swap button 'add to cart' with a component AddToCart

In browser click on Add to Cart button and check Inspector-> Network tab -> localhost requests.

================ #41 — Displaying Cart Items and Totals (20:00)

================ #42 — Removing Cart Items (10:45)

================ #43 — Optimistic Response && Cache Updates with Apollo (07:55)

================ #44 — Animating our Cart Count Component (13:20)

================ #45 — Dealing with Deleted Items in CartItems (03:01)

================ ================ ================ ================  ================ ================
================ Module 7 - Advanced UI and Code Quality (38min)================ 
================ ================ ================ ================ 
================ #46 — Cleaning Up This Render Prop Mess (06:20)
In Cart.js there are <User>, <Mutation> and <Query> components - it's mess - слишком большая вложенность.
Solution:
import { adopt } from 'react-adopt';    // for dealing with render prop mess
// make new component called 'Composed'
const Composed = adopt ({
    user: <User/>,
    toggleCart: <Mutation mutation={TOGGLE_CART_MUTATION},
    localState: <Query query={LOCAL_STATE_QUERY},
});
// replace <User> with <Composed>

================ #47 — Search Dropdown Autocomplete (18:13)
Use 'downshift' package (it's search with dropdown) released by Paypal https://github.com/downshift-js/downshift
Create Search.js -> add a list of imports -> add 'AutoComplete' class -> add SEARCH_ITEMS_QUERY.
In Header.js import our search.

================ #48 — Autocomplete with Downshift (13:08)

================ ================ ================ ================  ================ ================
================ Module 8 - Credit Card Checkout (1h 19min)================ 
================ ================ ================ ================ 
================ #49 — Credit Card Processing with Stripe Checkout (16:45)
We're going to be using a credit card processor called Stripe https://stripe.com/ -> sign up for an account -> 
-> confirm through email -> activate 'Viewing test data' ->  Developers tab -> API keys -> see token ->
copy 'Publishing key' -> 
Create /components/TakeMyMoney.js -> add imports including 'import StripeCheckout from 'react-stripe-checkout' ->
-> write TakeMyMoney class.
import TakeMyMoney into Cart.js
Check documentation for react stripe checkout https://github.com/azmenak/react-stripe-checkout
Don't put your credit card for testing -> google 'stripe testing credit cards' https://stripe.com/docs/testing, expiring date can be anything, e.g. 02/22, CVC too, e.g. 222.

================ #50 — Charging Cards on the Server Side (17:50)
Task: 1) Charge token on the server side, 2) convert cart items into order item(create type order). 
In datamodel.graphql create a new type called OrderItem and Order.
In schema.graphql add createOrder mutation.
Create a resolver from that mutation in Mutation.js.

================ #51 — Saving Orders to the Database (13:14)

================ #52 — Displaying Single Orders (17:57)
Create /pages/order.js
Create /components/Order.js
Open schema.graphql and add 'order' query -> write resolver for query in Query.js.

================ #53 — Orders Page (14:19)
Create /pages/orders.js
Create /components/OrderList.js
Open schema.graphql and add 'orders' query -> write resolver for query in Query.js.

================ ================ ================ ================  ================ ================
================ Module 9 - Testing (3h 20min)================ 
================ ================ ================ ================ 
================ #54 — Testing with Jest and Enzyme Introduction (07:44)
Tools:
1) Jest https://jestjs.io/ - testing framework for js, test runner
> npm run test
Check expect methods: https://jestjs.io/docs/en/expect
Open package.json -> find jest config.
In jest.setup.js you'll find enzyme config.

2) Enzyme https://airbnb.io/enzyme/ - to test React components via shallow render or by mounting it, React Test Renderer

================ #55 — Unit Testing 101 (16:30)
/components
    /Pagination
        index.js
        style.js
        Pagination.js

OR (we'll create __tests__ folder inside of frontend folder for simplisity)

/components
    /Pagination
        __tests__/
            whatever.test.js
        index.js
        style.js

VS Code package (optionally)
xit() - it.skip()
fit() - focus - it.only()
jest --watch - will monitor only files that was changed, it's won't check files from previous git commit.

Create /__tests__/formatMoney.test.js

================ #56 — Mocking 101 (09:47)
Create /__tests__/mocking.test.js
mock function


================ #57 — First Tests and Shallow Rendering (14:38)
Testing components.
We're going to start with Item component because this Item component doesn't actually have any queries or mutations in it.
It's actually just past in via props and then we display it. So we're going to 
    - import this component into a test.
    - render it on out.
    - check that all these things are working as planned: check that the description is there and that the title is there,
    and that the image is there, and that the price is being formatted properly,

Create /__tests/item.test.js
Check doc https://airbnb.io/enzyme/docs/api/ShallowWrapper/debug.html

================ #58 — Snapshot Testing (15:18)
/__tests__/__snapshots__ folder will be created.

================ #59 — Testing and Mocking Apollo Queries (19:40)

================ #60 — More Apollo Query Testing (20:55)

================ #61 — Testing Pagination (15:18)

================ #62 — Testing Mutations (25:47)

================ #63 — More Apollo Client Mutation Testing (15:21)

================ #64 — Testing our Cart (25:22)

================ #65 — Testing Order Components (15:31)

================ ================ ================ ================  ================ ================
================ Module 10 - Deployment (28min)================ 
================ ================ ================ ================ 
You get three different things to deploy:
1) Prisma Server:
    1. MySQL
2) Yoga Server
    Mutation and Query Resolvers
3) React app 
    next.js

================ #66 — Deploying a Prisma Server to Heroku (06:49)
Heroku will support frontend and backend of our application.
Go to prisma dashboard -> Add a server(our case) / Create a hosted server -> Server name: 'sick-fits-production' ->
-> Create a new database(our case) / Connect to an existing database -> Heroku -> sign in with your heroku account ->
-> take free plan -> Set up a server -> Heroku -> choose free plan -> Prisma server was successfully deployed! -> View the server.
-> you won't see a service for it because you need to deploy the app on the backend.

Go to backend -> npm run deploy -- -n   -> questions in the terminal:
- Set up a new Prisma server or deploy to an existing server? - wesbos/sick-fits-production
- Choose a name for your service - sick-fits-prod
- Choose a name for your stage - prod

Go to prisma.yml -> uncomment secter and change endpoint.
> npm run deploy

================ #67 — Deploying Yoga Server to Heroku or Now (11:47)
1) install the Heroku CLI https://devcenter.heroku.com/articles/heroku-cli
> heroku --help
> heroku login

> git add -A
> git commit -m 'all code'
2) create a heroku application
> heroku apps:create sickfits-yoga-prod     // you'll see your app on heroku dashboard
Now, it will give you this git URL right here, by default it's going to get it listed as a remote.
> git remote -v
However, we're not actually going to be using the heroku remote because we need to just deploy sub-folders.
So, what were gonna do is were gonna add some more remotes that are for heroku frontend and heroku backend.
Go ahead and copy that git that you have right here or you can just copy it from typing git remote-v.
> git remote add heroku-backend https://git.heroku.com/sickfits-yoga-prod.git
> git subtree -- prefix backend heroku-backend master

In production we'll be running 'npm run start'

> heroku logs --tail

Go to your heroku backend -> sickfits-yoga-prod -> Settings -> click on 'Reveal config vars' -> 
-> copy, paste all of .env values in here.

Again:
> git add -A
> git commit -m 'all code'
> git subtree -- prefix backend heroku-backend master

How to deploy on Now platform.
sign up
> npm i now -g
> cd backend    
> now       // it'll automatically give you a URL
Check doc to deal with .env https://zeit.co/docs/v1/features/env-and-secrets

================ #68 — Deploying Frontend to Heroku and Now (09:43)
In config.js add a row:   export const prodEndpoint = `https://sickfits-yoga-prod.herokuapp.com/`;
In withData.js import prodEndpoint and change 
    from    'development' ? endpoint : endpoint
    to      'development' ? endpoint : prodEndpoint

Go to main folder
> git remote -v
> heroku apps:create sickfits-next-prod     //It's going to create a new git repo for us
> git remote add heroku-frontend https://git.heroku.com/sickfits-next-prod.git
> git remote -v
> git add -A
> git commit -m 'prod url'
> npm run build     // that's going to create .next folder for us. And that's where the actual build of our application is getting dumped into.
                    The problem with that is that, you don't want to put this .next on a git repo because it's just a bundled version,
                    it's a compiled version of it but because heroku uses git to push it, we're in sort of a pickle where I don't want this part
                    of my report but I do want to push it to heroku. So what we're gonna do is we're gonna add a little hook
                    for heroku that is going to actually build this for us but on their server.
add a new script in package.json called "heroku-postbuild": "next build"
modify start script from "start": "next start"      to      "start": "next start -p $PORT" 
> git add -A
> git commit -m 'postbuild'
make sure you're in the main folder not the frontend folder.
> git subtree push -- prefix frontend heroku-frontend master

Open https://sickfits-next-prod.herokuapp.com in browser -> open Console -> see errors.
> it's because our current front-end URL set to localhost 777 in heroku settings -> change it there.
Now when you do change this, you do need to reboot your server-side.
Click on 'More' -> 'Restart all dynos'

In Now it's the same process as in backend above(just cd frontend).